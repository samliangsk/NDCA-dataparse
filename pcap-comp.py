# -*- coding: utf-8 -*-
"""
PCAP Packet Composition Analyzer

This script reads a PCAP file, analyzes its packets, and provides a summary
of the traffic composition based on a user-defined mapping of ports to services.

This script is originally generated by Google Gemini, and modified with human hands. 
"""
import sys
import csv
from collections import Counter
from scapy.all import rdpcap, TCP, UDP, IP

# --- Configuration ---
PCAP_FILE = "capture.pcap"
PORT_SERVICE_CSV = "service-names-port-numbers.csv"
# --- End of Configuration ---


def load_port_map_from_csv(csv_file):
    """
    Loads a port-to-service mapping from a two-column CSV file (port,service).

    Args:
        csv_file (str): The path to the CSV file.

    Returns:
        dict: A dictionary mapping integer port numbers to service name strings.
              Returns an empty dictionary if the file cannot be read.
    """
    port_map = {}
    try:
        with open(csv_file, mode='r', newline='', encoding='utf-8') as infile:
            reader = csv.reader(infile)
            # Skip header row if it exists
            try:
                # Read the first row to check for headers
                first_row = next(reader)
                if first_row[0].strip().lower() == 'service name' and first_row[1].strip().lower() == 'port number':
                    pass # It's a header, so we just move on
                else:
                    # Not a header, process it as the first data row
                    port = int(first_row[0].strip())
                    service = first_row[1].strip()
                    port_map[port] = service
            except StopIteration:
                # File is empty
                return {}

            # Process remaining rows
            for row in reader:
                if not row or len(row) < 2:
                    continue # Skip empty or malformed rows
                try:
                    service = row[0].strip()
                    port = int(row[1].strip())
                    port_map[port] = service
                except (ValueError, IndexError) as e:
                    print(f"Warning: Skipping malformed row in {csv_file}: {row} -> {e}")
    except FileNotFoundError:
        print(f"Error: The CSV file '{csv_file}' was not found.")
        print("Please create it or update the PORT_SERVICE_CSV variable.")
        return {}
    except Exception as e:
        print(f"An error occurred while reading the CSV file: {e}")
        return {}

    return port_map


def analyze_pcap(pcap_file, port_map):
    """
    Reads and analyzes a PCAP file to report on traffic composition.

    Args:
        pcap_file (str): The file path to the PCAP file.
        port_map (dict): A dictionary mapping port numbers to service names.

    Returns:
        tuple: A tuple containing (packet_composition_counter, total_packets, non_ip_packets).
               - packet_composition_counter (Counter): A Counter object with service names as keys
                 and packet counts as values.
               - total_packets (int): The total number of packets read from the file.
               - non_ip_packets (int): The count of packets that do not have an IP layer.
    """
    try:
        packets = rdpcap(pcap_file)
    except FileNotFoundError:
        print(f"Error: The file '{pcap_file}' was not found.")
        print("Please update the PCAP_FILE variable in the script.")
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred while reading the PCAP file: {e}")
        sys.exit(1)

    # Use a Counter for efficient counting.
    packet_composition = Counter()
    non_ip_count = 0

    # Iterate through each packet in the capture
    for packet in packets:
        # We are primarily interested in IP traffic for TCP/UDP ports
        if not packet.haslayer(IP):
            non_ip_count += 1
            continue

        # Default category for IP packets that don't match our criteria
        service = "Other IP Traffic"

        # Check for TCP layer
        if packet.haslayer(TCP):
            sport = packet[TCP].sport
            dport = packet[TCP].dport
            # Check if source or destination port is in our map
            service = port_map.get(sport, port_map.get(dport, "Other TCP"))

        # Check for UDP layer
        elif packet.haslayer(UDP):
            sport = packet[UDP].sport
            dport = packet[UDP].dport
            service = port_map.get(sport, port_map.get(dport, "Other UDP"))

        packet_composition[service] += 1

    return packet_composition, len(packets), non_ip_count


def print_results(composition, total_count, non_ip_count):
    """
    Prints the analysis results in a formatted table.

    Args:
        composition (Counter): The counter object with service counts.
        total_count (int): Total number of packets processed.
        non_ip_count (int): Number of non-IP packets found.
    """
    print("--- PCAP Analysis Results ---")
    print(f"Processed a total of {total_count} packets from '{PCAP_FILE}'.\n")

    if not composition and non_ip_count == 0:
        print("No identifiable IP traffic was found.")
        return

    # Find the longest service name for formatting the table
    max_len = max(len(s) for s in composition.keys()) if composition else 10
    
    print(f"{'Service':<{max_len}} | {'Packet Count':>15} | {'Percentage':>12}")
    print(f"{'-' * max_len}-+-----------------+-------------")

    # Sort by the most common services
    for service, count in composition.most_common():
        percentage = (count / total_count) * 100
        print(f"{service:<{max_len}} | {count:>15} | {percentage:11.2f}%")

    if non_ip_count > 0:
        percentage = (non_ip_count / total_count) * 100
        print(f"{'Non-IP Traffic':<{max_len}} | {non_ip_count:>15} | {percentage:11.2f}%")
        
    print("-" * (max_len + 33))


if __name__ == "__main__":
    # 1. Load the port service map from the CSV file
    port_service_map = load_port_map_from_csv(PORT_SERVICE_CSV)

    if not port_service_map:
        print("\nAborting analysis because the port service map is empty or could not be loaded.")
        sys.exit(1)

    print(f"Successfully loaded {len(port_service_map)} port-service mappings from '{PORT_SERVICE_CSV}'.")

    # 2. Analyze the PCAP file
    composition_counter, total_packets, non_ip_packets = analyze_pcap(PCAP_FILE, port_service_map)

    # 3. Print the formatted results
    print_results(composition_counter, total_packets, non_ip_packets)

